import{_ as e,o as a,c as o,V as t}from"./chunks/framework.92369faf.js";const C=JSON.parse('{"title":"简单总结","description":"","frontmatter":{"title":"简单总结"},"headers":[],"relativePath":"React/jichu.md","filePath":"React/jichu.md","lastUpdated":1686842923000}'),l={name:"React/jichu.md"},s=t(`<h2 id="setstate" tabindex="-1">setState <a class="header-anchor" href="#setstate" aria-label="Permalink to &quot;setState&quot;">​</a></h2><ul><li>直接写 <code>setState</code> 是一个异步的执行过程。</li><li><code>setTimeout</code> 中写 <code>setState</code> 是一个同步的执行过程。</li><li>还有一些自定义 <code>DOM</code> 事件中写 <code>setState</code> 也是一个同步的执行过程。</li></ul><h2 id="函数组件" tabindex="-1">函数组件 <a class="header-anchor" href="#函数组件" aria-label="Permalink to &quot;函数组件&quot;">​</a></h2><ul><li>纯函数，输入 props，输出 JSX。</li><li>没有实例，没有生命周期，没有 state。</li><li>不能扩展其他方法。</li></ul><h2 id="非受控组件使用场景" tabindex="-1">非受控组件使用场景 <a class="header-anchor" href="#非受控组件使用场景" aria-label="Permalink to &quot;非受控组件使用场景&quot;">​</a></h2><ul><li>必须手动操作 DOM 元素，setState 实现不了的。</li><li>文件上传这种交互的 setState 实现不了。</li><li>某些富文本编辑器，需要传入 DOM 元素。</li></ul><h3 id="受控组件-vs-非受控组件" tabindex="-1">受控组件 VS 非受控组件 <a class="header-anchor" href="#受控组件-vs-非受控组件" aria-label="Permalink to &quot;受控组件 VS 非受控组件&quot;">​</a></h3><ul><li>优先使用受控组件，符合 React 设计原则。（数据驱动视图）</li><li>必须操作 DOM 时再使用非受控组件。</li></ul><h2 id="portals-使用场景" tabindex="-1">Portals 使用场景 <a class="header-anchor" href="#portals-使用场景" aria-label="Permalink to &quot;Portals 使用场景&quot;">​</a></h2><ul><li>父组件设置了一些像 overflow:hidden; 等触发 BFC 的属性，影响子组件的展示。</li><li>父组件 z-index 值太小。</li><li>fixed 需要放在 body 第一层级。</li></ul><h2 id="context" tabindex="-1">context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;context&quot;">​</a></h2><ul><li>设置一些公共信息（语言、主题、颜色之类的），可以在每个组件里使用。</li><li>用 props 感觉太繁琐。</li><li>用 Redux 又小题大做。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 创建 Context 填入默认值（任何一个 js 变量）</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ThemeContext </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createContext</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">light</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="异步组件" tabindex="-1">异步组件 <a class="header-anchor" href="#异步组件" aria-label="Permalink to &quot;异步组件&quot;">​</a></h2><ul><li>React.lazy</li><li>React.Suspense</li></ul><p><code>Suspense</code> <code>使得组件可以“等待”某些操作结束后，再进行渲染。目前，Suspense</code> 仅支持的使用场景是：通过 <code>React.lazy</code> 动态加载组件。它将在未来支持其它使用场景，如数据获取等。</p><h2 id="scu-使用总结" tabindex="-1">SCU 使用总结 <a class="header-anchor" href="#scu-使用总结" aria-label="Permalink to &quot;SCU 使用总结&quot;">​</a></h2><ul><li><code>SCU</code> 默认返回 <code>true</code> ，即 <code>React</code> 默认重新渲染所有子组件。</li><li>当 <code>props</code> 或 <code>state</code> 发生变化时，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 <code>true</code>。首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</li><li>不建议在 <code>shouldComponentUpdate()</code> 中进行深层比较或使用 <code>JSON.stringify()</code>。这样非常影响效率，且会损害性能。</li><li>此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 <code>bug</code>。你应该考虑使用内置的 <code>PureComponent</code> 组件，而不是手动编写 <code>shouldComponentUpdate()</code>。<code>PureComponent</code> 会对 <code>props</code> 和 <code>state</code> 进行浅层比较，并减少了跳过必要更新的可能性。</li></ul><h2 id="purecomponent-和-memo" tabindex="-1">PureComponent 和 memo <a class="header-anchor" href="#purecomponent-和-memo" aria-label="Permalink to &quot;PureComponent 和 memo&quot;">​</a></h2><ul><li><code>PureComponent</code> 其实就是在 SCU 中实现了浅比较。</li><li><code>memo</code> 函数组件中的 <code>PureComponent</code>。</li></ul>`,20),c=[s];function n(i,d,r,p,u,h){return a(),o("div",null,c)}const b=e(l,[["render",n]]);export{C as __pageData,b as default};

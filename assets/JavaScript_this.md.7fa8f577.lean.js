import{_ as e,H as t,o as c,c as r,C as s,a as n,J as l,E as p,V as o}from"./chunks/framework.364d6ed5.js";const y="/assets/this.f7d9f80e.png",ps=JSON.parse('{"title":"this 优先级","description":"","frontmatter":{"title":"this 优先级"},"headers":[],"relativePath":"JavaScript/this.md","filePath":"JavaScript/this.md","lastUpdated":1686887724000}'),F={name:"JavaScript/this.md"},D=s("h3",{id:"🔥字节跳动面试官—麻烦你搞个方法出来🌈使得以下程序最后能输出-success",tabindex:"-1"},[n("🔥字节跳动面试官—麻烦你搞个方法出来🌈使得以下程序最后能输出 success "),s("a",{class:"header-anchor",href:"#🔥字节跳动面试官—麻烦你搞个方法出来🌈使得以下程序最后能输出-success","aria-label":'Permalink to "🔥字节跳动面试官—麻烦你搞个方法出来🌈使得以下程序最后能输出 success"'},"​")],-1),i=s("h2",{id:"前言",tabindex:"-1"},[n("前言 "),s("a",{class:"header-anchor",href:"#前言","aria-label":'Permalink to "前言"'},"​")],-1),A=s("strong",null,"本文会以详细讲解一道",-1),C=s("strong",null,"字节面试题",-1),b=s("strong",null,"的方式，循序渐进完全搞定 js 中 this 指向优先级的问题。",-1),d=s("a",{href:"https://juejin.im/user/58ad9da68fd9c50067049cab",target:"_blank",rel:"noreferrer"},"猛哥",-1),u=o("",8),m=s("strong",null,"this 永远指向 最后调用它的那个对象",-1),h=o("",3),f=s("strong",null,"this 永远指向 最后调用它的那个对象",-1),_=s("code",null,"a()",-1),g=s("code",null,"window",-1),E=s("code",null,"console.log(this.name)",-1),j=s("code",null,"console.log(window.name)",-1),v=s("code",null,"globalName",-1),w=o("",2),q=s("strong",null,"this 永远指向 最后调用它的那个对象",-1),B=s("code",null,".",-1),k=s("code",null,"console.log(this.name)",-1),T=s("code",null,"console.log(a.name)",-1),P=s("code",null,"jingjing",-1),S=o("",10),x=s("code",null,"call()",-1),V=s("code",null,"apply()",-1),I=s("strong",null,"立即执行函数",-1),N=o("",1),O=s("code",null,"bind()",-1),R=s("strong",null,"返回一个新的包装函数",-1),J=s("code",null,"bind()",-1),$=s("code",null,"bind()",-1),H=s("code",null,"this",-1),U=o("",9),z=o("",9),G=o("",16),K={id:"这里就涉及到前面讲到的-js-中-this-绑定规则的优先级问题了。我们写的-mybind-函数里面没有做优先级的判断-换句话说就是没有对不同的-this-绑定规则做出相应的-this-绑定-。",tabindex:"-1"},L=s("code",null,"myBind()",-1),M=s("a",{class:"header-anchor",href:"#这里就涉及到前面讲到的-js-中-this-绑定规则的优先级问题了。我们写的-mybind-函数里面没有做优先级的判断-换句话说就是没有对不同的-this-绑定规则做出相应的-this-绑定-。","aria-label":'Permalink to "这里就涉及到前面讲到的 js 中 this 绑定规则的优先级问题了。我们写的 `myBind()` 函数里面没有做优先级的判断 ***（<font color="Darkorange">换句话说就是没有对不同的 this 绑定规则做出相应的 this 绑定</font>）。***"'},"​",-1),Q=o("",14);function W(X,Y,Z,ss,ns,as){const a=t("font");return c(),r("div",null,[D,i,s("p",null,[A,n(),l(a,{color:"FireBrick"},{default:p(()=>[C]),_:1}),b,n(" ⛹️‍♂️⛹️‍♂️ js 中的 this 指向问题应该是一个讨论了很久的话题了，关于这个话题的文章，在掘金也有很多。但是，可能之前看到的文章不怎么适合自己，每次看完都还是似懂非懂、没有多少头绪。前几天幸得我的老学长—— "),d,n(" 的交流之后，好像对这个问题理解的更深了些，写篇文章总结一下。🌈")]),u,s("ul",null,[s("li",null,[n("在 ES5 中， this 的指向始终是一个原则：this 的指向并不是在创建的时候就可以确定的，在 es5 中， "),l(a,{color:"FireBrick"},{default:p(()=>[m]),_:1}),n("。")])]),h,s("p",null,[n("根据刚刚上面那个原则： "),l(a,{color:"FireBrick"},{default:p(()=>[f]),_:1}),n(" 可以得到答案。我们看最后调用 a 的地方是在哪里？在最后一行代码"),_,n("; 它前面没有调用的对象，那么就是默认的全局对象 "),g,n("，所以"),E,n("就变成了"),j,n(",结果输出的是 "),v,n("（👉非严格模式下👈）。")]),w,s("p",null,[n("我又要重复上面那句话了😁。 "),l(a,{color:"FireBrick"},{default:p(()=>[q]),_:1}),n("可以得到答案。我们看最后调用 fn() 函数 的地方是在哪里？或者说函数 fn() 左边这个"),B,n("的左边的对象是哪个？显然是对象 a，所以"),k,n("就变成了"),T,n(",结果输出的是"),P,n("。")]),S,s("ul",null,[s("li",null,[x,n(" 和 "),V,n(" 都是 "),l(a,{color:"FireBrick"},{default:p(()=>[I]),_:1}),n(" ，但是它们接受的参数的形式不同，具体如下：")])]),N,s("ul",null,[s("li",null,[n("而 "),O,n(" 则是 "),l(a,{color:"FireBrick"},{default:p(()=>[R]),_:1}),n("，而不是立刻执行。"),J,n("会创建一个新函数。当这个新函数被调用时，"),$,n(" 的第一个参数将作为它运行时的 "),H,n("，之后的一序列参数将会在传递的实参前传入作为它的参数。")])]),U,l(a,{color:"FireBrick"},{default:p(()=>[n("**new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定**")]),_:1}),z,l(a,{color:"FireBrick"},{default:p(()=>[n("**new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定**")]),_:1}),G,s("h4",K,[n("这里就涉及到前面讲到的 js 中 this 绑定规则的优先级问题了。我们写的 "),L,n(" 函数里面没有做优先级的判断 "),s("em",null,[s("strong",null,[n("（"),l(a,{color:"Darkorange"},{default:p(()=>[n("换句话说就是没有对不同的 this 绑定规则做出相应的 this 绑定")]),_:1}),n("）。")])]),n(),M]),Q])}const os=e(F,[["render",W]]);export{ps as __pageData,os as default};

import{_ as s,o as l,c as a,V as e}from"./chunks/framework.92369faf.js";const D=JSON.parse('{"title":"node 模块化","description":"","frontmatter":{},"headers":[],"relativePath":"node/模块化相关.md","filePath":"node/模块化相关.md","lastUpdated":1686842923000}'),o={name:"node/模块化相关.md"},n=e(`<h1 id="node-模块化" tabindex="-1">node 模块化 <a class="header-anchor" href="#node-模块化" aria-label="Permalink to &quot;node 模块化&quot;">​</a></h1><h2 id="没有模块化带来的问题" tabindex="-1">没有模块化带来的问题 <a class="header-anchor" href="#没有模块化带来的问题" aria-label="Permalink to &quot;没有模块化带来的问题&quot;">​</a></h2><p>早期没有模块化带来了很多的问题：<strong>比如命名冲突的问题</strong></p><p>当然，我们有办法可以解决上面的问题：立即函数调用表达式（IIFE）IIFE (Immediately Invoked Function Expression) 但是，我们其实带来了新的问题：</p><ul><li>第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用。</li><li>第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写。</li><li>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况。</li></ul><h2 id="commonjs-和-node" tabindex="-1">CommonJS 和 Node <a class="header-anchor" href="#commonjs-和-node" aria-label="Permalink to &quot;CommonJS 和 Node&quot;">​</a></h2><p><strong>我们需要知道CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为 ServerJS，后来为了 体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS。</strong></p><ul><li>Node 是 CommonJS 在服务器端一个具有代表性的实现</li><li>Browserify 是 CommonJS在浏览器中的一种实现。</li><li>webpack 打包工具具备对 CommonJS 的支持和转换。</li></ul><p><strong>所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发</strong></p><ul><li>在Node中每一个js文件都是一个单独的模块。</li><li>这个模块中包括CommonJS规范的核心变量：exports、module.exports、require。</li><li>我们可以使用这些变量来方便的进行模块化开发。</li></ul><p><strong>前面我们提到过模块化的核心是导出和导入，Node中对其进行了实现。</strong></p><ul><li>exports和module.exports可以负责对模块中的内容进行导出。</li><li>require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容。</li></ul><h2 id="exports-和-require" tabindex="-1">exports 和 require <a class="header-anchor" href="#exports-和-require" aria-label="Permalink to &quot;exports 和 require&quot;">​</a></h2><h3 id="exports-和-module-exports-与-require-的关系" tabindex="-1">exports 和 module.exports 与 require() 的关系 <a class="header-anchor" href="#exports-和-module-exports-与-require-的关系" aria-label="Permalink to &quot;exports 和 module.exports 与 require() 的关系&quot;">​</a></h3><ul><li>exports 就是一个对象，往外导出东西的时候直接可以往上面挂就可以了。for example：</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 就是一个模块</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 1.模块内部定义东西</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">jingjing</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> age </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">18</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> message </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">my name is why</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sayHello</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 通过exports导出内容</span></span>
<span class="line"><span style="color:#89DDFF;">exports.</span><span style="color:#A6ACCD;">name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">exports.</span><span style="color:#A6ACCD;">age </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> age</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">exports.</span><span style="color:#A6ACCD;">sayHello </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> sayHello</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li><p>CommonJS 中是没有 module.exports 的概念的；</p></li><li><p>但是为了实现模块的导出，Node 中使用的是 Module的 类，每一个模块都是 Module 的一个实例，也就是 module。</p></li><li><p>所以在 Node 中真正用于导出的其实根本不是 exports，而是 module.exports。</p></li><li><p>require() 和 exports 还有 module.exports 三个其实共同引用着同一个内存地址。但是当 module.exports 直接导出一个对象的时候，require() 就只能得到这个对象了，exports导出的东西就没有任何作用。（本质都是内存的知识）</p></li><li><p>其实真正负责导出东西的是 module.exports，而不是 exports。之所以 exports 也能向外导出东西是因为 node 在源码中执行了特殊处理，让 module.exports = exports。（这样做的原因就是兼容 CommonJS的特点）。</p></li></ul><h3 id="require-函数的处理细节" tabindex="-1">require() 函数的处理细节 <a class="header-anchor" href="#require-函数的处理细节" aria-label="Permalink to &quot;require() 函数的处理细节&quot;">​</a></h3><ul><li><p>某个模块第一次使用 require() 函数引入的时候，模块中的代码会先加载一遍。</p></li><li><p>模块如果被多次引入的时候，只会加载一遍。因为每个模块对象 module 里面都有一个属性 loaded，为false表示还没有加载，为true则表示已经加载过了，就不会再重复加载了。</p></li><li><p>我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象。</p></li><li><p>那么，require的查找规则是怎么样的呢？<a href="https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together" target="_blank" rel="noreferrer">https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together</a></p></li></ul><p><strong>这里我总结比较常见的查找规则：导入格式如下：require(X)</strong></p><p><strong>情况一：X是一个核心模块，比如 path、http</strong> 直接返回核心模块，并且停止查找。</p><p><strong>情况二：X是以 ./ 或 ../ 或 /（根目录）开头的</strong></p><ul><li>第一步：将X当做一个文件在对应的目录下查找。 1.如果有后缀名，按照后缀名的格式查找对应的文件 2.如果没有后缀名，会按照如下顺序： 1&gt; 直接查找文件X 2&gt; 查找X.js文件 3&gt; 查找X.json文件 4&gt; 查找X.node文件</li><li>第二步：没有找到对应的文件，将X作为一个目录，查找目录下面的index文件 <ol><li>查找X/index.js文件</li><li>查找X/index.json文件</li><li>查找X/index.node文件</li></ol></li><li>如果没有找到，那么报错：not found</li></ul><p><strong>情况三：直接是一个X（没有路径），并且X不是一个核心模块</strong></p><ul><li>这时候会去当前文件的 module 对象上的 path 数组里面对应的node_modules里面找。</li></ul><h2 id="commonjs-规范缺点" tabindex="-1">CommonJS 规范缺点 <a class="header-anchor" href="#commonjs-规范缺点" aria-label="Permalink to &quot;CommonJS 规范缺点&quot;">​</a></h2><h3 id="commonjs-加载模块是同步的。" tabindex="-1">CommonJS 加载模块是同步的。 <a class="header-anchor" href="#commonjs-加载模块是同步的。" aria-label="Permalink to &quot;CommonJS 加载模块是同步的。&quot;">​</a></h3><ul><li><p>同步意味着只有等到引入的模块加载完了，才会执行当前模块的内容。</p></li><li><p>这个如果在服务器中不会有问题，因为服务器加载的js文件都是本地文件，加载速度非常快。</p></li></ul><h3 id="在浏览器使用-commonjs-规范" tabindex="-1">在浏览器使用 CommonJS 规范？ <a class="header-anchor" href="#在浏览器使用-commonjs-规范" aria-label="Permalink to &quot;在浏览器使用 CommonJS 规范？&quot;">​</a></h3><ul><li><p>浏览器加载 js 文件需要先从服务器将文件下载下来，之后再加载运行。</p></li><li><p>那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作。</p></li></ul><h3 id="所以早期在浏览器中是不使用-commonjs-规范的" tabindex="-1">所以早期在浏览器中是不使用 CommonJS 规范的 <a class="header-anchor" href="#所以早期在浏览器中是不使用-commonjs-规范的" aria-label="Permalink to &quot;所以早期在浏览器中是不使用 CommonJS 规范的&quot;">​</a></h3><ul><li><p>在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD。</p></li><li><p>目前一方面现代的浏览器已经支持ES Modules，另一方面借助于 webpack 等打包工具可以实现对 CommonJS或者 ES Module代码的转换。所以现在AMD和CMD已经使用非常少了。</p></li></ul><h2 id="模块化演变" tabindex="-1">模块化演变 <a class="header-anchor" href="#模块化演变" aria-label="Permalink to &quot;模块化演变&quot;">​</a></h2><h3 id="amd" tabindex="-1">AMD <a class="header-anchor" href="#amd" aria-label="Permalink to &quot;AMD&quot;">​</a></h3><ul><li>代表的有 require.js</li></ul><h3 id="cmd" tabindex="-1">CMD <a class="header-anchor" href="#cmd" aria-label="Permalink to &quot;CMD&quot;">​</a></h3><ul><li>代表的有 sea.js</li></ul><h3 id="es-module" tabindex="-1">ES_Module <a class="header-anchor" href="#es-module" aria-label="Permalink to &quot;ES_Module&quot;">​</a></h3><ul><li><p>import 是一个关键字，只可以在代码加载（编译）过程中引入模块。</p></li><li><p>import() 是一个函数，可以在代码运行中引入模块。（动态加载）</p></li><li><p>采用ES Module将自动采用严格模式：use strict。</p></li><li><p>export {} 不是对象，只是特定的语法。</p></li></ul>`,39),p=[n];function r(t,i,c,m,u,d){return l(),a("div",null,p)}const y=s(o,[["render",r]]);export{D as __pageData,y as default};

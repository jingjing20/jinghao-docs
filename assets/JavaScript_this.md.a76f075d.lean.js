import{_ as e,H as c,o as t,c as r,C as s,a as n,J as p,E as o,V as a}from"./chunks/framework.92369faf.js";const y="/jinghao-docs/assets/this.f7d9f80e.png",ls=JSON.parse('{"title":"this 优先级","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScript/this.md","filePath":"JavaScript/this.md","lastUpdated":1686913266000}'),F={name:"JavaScript/this.md"},D=a("",3),i=s("strong",null,"本文会以详细讲解一道",-1),A=s("strong",null,"字节面试题",-1),C=s("strong",null,"的方式，循序渐进完全搞定 js 中 this 指向优先级的问题。",-1),b=s("a",{href:"https://juejin.im/user/58ad9da68fd9c50067049cab",target:"_blank",rel:"noreferrer"},"猛哥",-1),d=a("",8),u=s("strong",null,"this 永远指向 最后调用它的那个对象",-1),m=a("",3),h=s("strong",null,"this 永远指向 最后调用它的那个对象",-1),_=s("code",null,"a()",-1),f=s("code",null,"window",-1),g=s("code",null,"console.log(this.name)",-1),E=s("code",null,"console.log(window.name)",-1),j=s("code",null,"globalName",-1),v=a("",2),w=s("strong",null,"this 永远指向 最后调用它的那个对象",-1),B=s("code",null,".",-1),T=s("code",null,"console.log(this.name)",-1),k=s("code",null,"console.log(a.name)",-1),q=s("code",null,"jingjing",-1),P=a("",10),S=s("code",null,"call()",-1),x=s("code",null,"apply()",-1),V=s("strong",null,"立即执行函数",-1),I=a("",1),N=s("code",null,"bind()",-1),O=s("strong",null,"返回一个新的包装函数",-1),R=s("code",null,"bind()",-1),J=s("code",null,"bind()",-1),$=s("code",null,"this",-1),H=a("",9),U=a("",9),z=a("",16),G={id:"这里就涉及到前面讲到的-js-中-this-绑定规则的优先级问题了。我们写的-mybind-函数里面没有做优先级的判断-换句话说就是没有对不同的-this-绑定规则做出相应的-this-绑定-。",tabindex:"-1"},K=s("code",null,"myBind()",-1),L=s("a",{class:"header-anchor",href:"#这里就涉及到前面讲到的-js-中-this-绑定规则的优先级问题了。我们写的-mybind-函数里面没有做优先级的判断-换句话说就是没有对不同的-this-绑定规则做出相应的-this-绑定-。","aria-label":'Permalink to "这里就涉及到前面讲到的 js 中 this 绑定规则的优先级问题了。我们写的 `myBind()` 函数里面没有做优先级的判断 **_（<font color="Darkorange">换句话说就是没有对不同的 this 绑定规则做出相应的 this 绑定</font>）。_**"'},"​",-1),M=a("",14);function Q(W,X,Y,Z,ss,ns){const l=c("font");return t(),r("div",null,[D,s("p",null,[i,n(),p(l,{color:"FireBrick"},{default:o(()=>[A]),_:1}),C,n(" ⛹️‍♂️⛹️‍♂️ js 中的 this 指向问题应该是一个讨论了很久的话题了，关于这个话题的文章，在掘金也有很多。但是，可能之前看到的文章不怎么适合自己，每次看完都还是似懂非懂、没有多少头绪。前几天幸得我的老学长—— "),b,n(" 的交流之后，好像对这个问题理解的更深了些，写篇文章总结一下。🌈")]),d,s("ul",null,[s("li",null,[n("在 ES5 中， this 的指向始终是一个原则：this 的指向并不是在创建的时候就可以确定的，在 es5 中， "),p(l,{color:"FireBrick"},{default:o(()=>[u]),_:1}),n("。")])]),m,s("p",null,[n("根据刚刚上面那个原则： "),p(l,{color:"FireBrick"},{default:o(()=>[h]),_:1}),n(" 可以得到答案。我们看最后调用 a 的地方是在哪里？在最后一行代码"),_,n("; 它前面没有调用的对象，那么就是默认的全局对象 "),f,n("，所以"),g,n("就变成了"),E,n(",结果输出的是 "),j,n("（👉 非严格模式下 👈）。")]),v,s("p",null,[n("我又要重复上面那句话了 😁。 "),p(l,{color:"FireBrick"},{default:o(()=>[w]),_:1}),n("可以得到答案。我们看最后调用 fn() 函数 的地方是在哪里？或者说函数 fn() 左边这个"),B,n("的左边的对象是哪个？显然是对象 a，所以"),T,n("就变成了"),k,n(",结果输出的是"),q,n("。")]),P,s("ul",null,[s("li",null,[S,n(" 和 "),x,n(" 都是 "),p(l,{color:"FireBrick"},{default:o(()=>[V]),_:1}),n(" ，但是它们接受的参数的形式不同，具体如下：")])]),I,s("ul",null,[s("li",null,[n("而 "),N,n(" 则是 "),p(l,{color:"FireBrick"},{default:o(()=>[O]),_:1}),n("，而不是立刻执行。"),R,n("会创建一个新函数。当这个新函数被调用时，"),J,n(" 的第一个参数将作为它运行时的 "),$,n("，之后的一序列参数将会在传递的实参前传入作为它的参数。")])]),H,p(l,{color:"FireBrick"},{default:o(()=>[n("**new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定**")]),_:1}),U,p(l,{color:"FireBrick"},{default:o(()=>[n("**new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定**")]),_:1}),z,s("h4",G,[n("这里就涉及到前面讲到的 js 中 this 绑定规则的优先级问题了。我们写的 "),K,n(" 函数里面没有做优先级的判断 "),s("strong",null,[s("em",null,[n("（"),p(l,{color:"Darkorange"},{default:o(()=>[n("换句话说就是没有对不同的 this 绑定规则做出相应的 this 绑定")]),_:1}),n("）。")])]),n(),L]),M])}const ps=e(F,[["render",Q]]);export{ls as __pageData,ps as default};

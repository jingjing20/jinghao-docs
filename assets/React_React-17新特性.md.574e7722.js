import{_ as s,o as a,c as n,V as l}from"./chunks/framework.92369faf.js";const u=JSON.parse('{"title":"React 17 新特性","description":"","frontmatter":{"title":"React 17 新特性"},"headers":[],"relativePath":"React/React-17新特性.md","filePath":"React/React-17新特性.md","lastUpdated":1686842923000}'),e={name:"React/React-17新特性.md"},o=l(`<h2 id="_1、更改事件委托" tabindex="-1">1、更改事件委托 <a class="header-anchor" href="#_1、更改事件委托" aria-label="Permalink to &quot;1、更改事件委托&quot;">​</a></h2><h3 id="更新前" tabindex="-1">更新前 <a class="header-anchor" href="#更新前" aria-label="Permalink to &quot;更新前&quot;">​</a></h3><p>从技术上讲，始终可以在应用程序中嵌套不同版本的 React。但是，由于 <strong><em>React 事件系统的工作原理</em></strong>，这很难实现。</p><ul><li>我们在 React 组件中写事件绑定一般会像如下实现：</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">handleClick</span><span style="color:#89DDFF;">}&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>对应的原生的 DOM 操作如下：</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">myButton</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">click</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> handleClick)</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><p>但是 React 实际上并不会将它们绑定到 DOM 节点上。React 中是直接在 <code>document</code>节点上为每一种事件类型都附加一个处理器。这和我们所知的事件委托是一个意思。</p></li><li><p>自从<code>React</code>发布以来，<code>React</code> 一直自动进行事件委托。当 <code>document</code> 上触发 <code>DOM</code> 事件时，<code>React</code> 会找出调用的组件，然后 <code>React</code> 事件会在组件中向上 “冒泡”。直到冒泡到了 <code>document</code> 上，React 在其中安装了事件处理器进行处理。</p></li></ul><h3 id="更新原因" tabindex="-1">更新原因 <a class="header-anchor" href="#更新原因" aria-label="Permalink to &quot;更新原因&quot;">​</a></h3><ul><li>React 一直以来遵循 <code>all-or-nothing</code> 的升级策略。你可以继续使用旧版本，也可以将整个应用程序升级至新版本。但没有介于两者之间的情况。就是不能渐进式更新，只能全量更新。</li><li><code>React 17</code> 想实现渐进式更新，意思是页面上可以有不同版本的 <code>React</code>。这样原来<code>React</code>中的事件委托机制就会产生问题了。如果页面上有多个 React 版本，他们都将在顶层注册事件处理器。这会破坏 <code>e.stopPropagation()</code>：如果嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它。这会使不同版本 React 嵌套变得困难重重。</li></ul><h3 id="更新后" tabindex="-1">更新后 <a class="header-anchor" href="#更新后" aria-label="Permalink to &quot;更新后&quot;">​</a></h3><ul><li><strong>在 React 17 中，React 将不再向 <code>document</code> 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中：</strong></li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> rootNode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">root</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">App</span><span style="color:#89DDFF;"> /&gt;,</span><span style="color:#A6ACCD;"> rootNode)</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>在 React 16 或更早版本中，React 会对大多数事件执行 <code>document.addEventListener()</code>。React 17 将会在底层调用 <code>rootNode.addEventListener()</code>。</li></ul><p><img src="https://zh-hans.reactjs.org/static/bb4b10114882a50090b8ff61b3c4d0fd/1e088/react_17_delegation.png" alt="A diagram showing how React 17 attaches events to the roots rather than to the document"></p><p>来源——<a href="https://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html" target="_blank" rel="noreferrer">React 官方文档</a></p><h2 id="_2、去除了事件池" tabindex="-1">2、去除了事件池 <a class="header-anchor" href="#_2、去除了事件池" aria-label="Permalink to &quot;2、去除了事件池&quot;">​</a></h2><h3 id="关于-react-中的合成事件的事件池" tabindex="-1">关于 React 中的合成事件的事件池 <a class="header-anchor" href="#关于-react-中的合成事件的事件池" aria-label="Permalink to &quot;关于 React 中的合成事件的事件池&quot;">​</a></h3><ul><li>在 React 17 之前，<code>合成事件对象</code> 会被放进一个叫 <code>事件池</code> 的地方统一管理。</li><li>这样做的目的是能够实现 <code>事件对象</code> 的复用，进而提高性能。</li><li>但是这样处理的话，每当事件处理函数执行完毕之后，对应的合成事件对象就会被<code>&quot;格式化&quot;</code>，为下一次复用做准备，这就意味着我们在事件处理函数执行完毕之后就拿不到事件对象了。如下这个例子（官方提供）</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">handleChange</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// This won&#39;t work because the event object gets reused.</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// Too late!</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">100</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>如果你在一个 DOM 元素上绑定上面这个事件处理函数，触发之后控制台会提示如下信息：</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Warning</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> This synthetic event is reused for performance reasons</span><span style="color:#89DDFF;">.</span></span>
<span class="line"><span style="color:#A6ACCD;">If you</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">re seeing this, you</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">re accessing the property </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">target</span><span style="color:#89DDFF;">\`</span><span style="color:#A6ACCD;"> on a released</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">nullified synthetic event</span><span style="color:#89DDFF;">.</span></span>
<span class="line"><span style="color:#A6ACCD;">This is set to null</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;"> If you must keep the original synthetic event around</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> use </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">event.persist()</span><span style="color:#89DDFF;">\`</span><span style="color:#89DDFF;">.</span></span>
<span class="line"><span style="color:#A6ACCD;">See </span><span style="color:#FFCB6B;">https</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//fb.me/react-event-pooling for more information.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>根据这个提示信息能够看到解决方法：要想拿到目标事件对象，必须显式地告诉 React——我永远需要它，也就是调用 <code>e.persist()</code> 函数，像下面这样：</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">handleChange</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// This won&#39;t work because the event object gets reused.</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">persist</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// Too late!</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">100</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>React 17 拥抱了新时代的潮流，重新在研发体验和向下兼容性能之间做了选择，这一次，它选择了前者——<strong>放弃事件池，为每一个合成事件创建新的对象</strong>。因此在 React 17 中，我们不需要 e.persist()，也可以随时随地访问我们想要的事件对象。</li></ul><h2 id="_3、useeffect-副作用清理时机的改动" tabindex="-1">3、useEffect 副作用清理时机的改动 <a class="header-anchor" href="#_3、useeffect-副作用清理时机的改动" aria-label="Permalink to &quot;3、useEffect 副作用清理时机的改动&quot;">​</a></h2><ul><li><p>React 16 中当组件被卸载时 useEffect 副作用中的清理函数是会同步执行的，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。</p></li><li><p><strong>在 React 17 中，副作用清理函数总会异步执行 —— 如果要卸载组件，则清理会在屏幕更新后运行。</strong></p><p>这反映了副作用本身如何更紧密地运行。在极少数情况下，你可能希望依靠同步执行，可以改用 <code>useLayoutEffect</code>。</p></li></ul><h2 id="_4、全新的-jsx-转换规则" tabindex="-1">4、全新的 JSX 转换规则 <a class="header-anchor" href="#_4、全新的-jsx-转换规则" aria-label="Permalink to &quot;4、全新的 JSX 转换规则&quot;">​</a></h2><h3 id="react-16-之前的转换规则" tabindex="-1">React 16 之前的转换规则 <a class="header-anchor" href="#react-16-之前的转换规则" aria-label="Permalink to &quot;React 16 之前的转换规则&quot;">​</a></h3><ul><li><p><code>React 17</code> 之前 <code>React</code> 中的 <code>jsx</code> 会被 <code>babel</code> 转换成 <code>React.createElement()</code> 的调用，在 <code>React.createElement()</code> 中对传入的参数进行一顿处理后，传入 <code>reactElement()</code> 并返回。</p></li><li><p>例如，假设源代码如下：</p></li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> React </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Hello World</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>旧的 JSX 转换会将上述代码变成普通的 JavaScript 代码：</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> React </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">h1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>在旧的转换规则下如果使用了 JSX，就必须在引入 <code>React</code>，因为 JSX 将被编译成 <code>React.createElement()</code>。</li></ul><h3 id="react-17-的转换规则" tabindex="-1">React 17 的转换规则 <a class="header-anchor" href="#react-17-的转换规则" aria-label="Permalink to &quot;React 17 的转换规则&quot;">​</a></h3><ul><li><p>React 17 在 React 的 package 中引入了两个新入口，这些入口只会被 Babel 和 TypeScript 等编译器使用。新的 JSX 转换<strong>不会将 JSX 转换为 <code>React.createElement</code></strong>，而是自动从 React 的 package 中引入新的入口函数并调用。</p></li><li><p>例如，假设源代码如下：</p></li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Hello World</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>下方是新 JSX 被转换编译后的结果：</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 由编译器引入（禁止自己引入！）</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">jsx</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">_jsx</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react/jsx-runtime</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">_jsx</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">h1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> children</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>注意，此时源代码<strong>无需引入 React</strong> 即可使用 JSX 了！ 当然了，如果要用到其他 React 中的导出还是需要引入 <code>React</code> 的。</li></ul>`,40),p=[o];function t(c,r,i,F,y,D){return a(),n("div",null,p)}const C=s(e,[["render",t]]);export{u as __pageData,C as default};

import{_ as l,H as i,o as t,c as s,C as e,a as o,J as c,E as d,V as r}from"./chunks/framework.364d6ed5.js";const M=JSON.parse('{"title":"浏览器缓存","description":"","frontmatter":{},"headers":[],"relativePath":"browser/浏览器缓存.md","filePath":"browser/浏览器缓存.md","lastUpdated":1686913266000}'),n={name:"browser/浏览器缓存.md"},p=r('<h1 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h1><p>接下来以三个部分来学习一下浏览器的缓存机制：</p><ul><li>强缓存</li><li>协商缓存</li><li>缓存的位置</li></ul><h2 id="_1、强缓存" tabindex="-1">1、强缓存 <a class="header-anchor" href="#_1、强缓存" aria-label="Permalink to &quot;1、强缓存&quot;">​</a></h2><ul><li><p>强缓存不需要发送 <code>HTTP</code> 请求。</p></li><li><p>是否强缓存由 <code>Expires</code>、<code>Cache-Control</code> 和 <code>Pragma</code> 3 个 <code>Header</code> 属性共同来控制。</p></li></ul><hr><p><code>HTTP/1.0</code>时期，是否强缓存使用的是<code>Expires</code>，而<code>HTTP/1.1</code>使用的是<code>Cache-Control</code>。让我们首先来看看<code>Expires</code>。</p><h3 id="expires" tabindex="-1">Expires <a class="header-anchor" href="#expires" aria-label="Permalink to &quot;Expires&quot;">​</a></h3><ul><li><code>Expires</code> 即过期时间，存在于服务器返回的响应头中，其用于告诉浏览器在某个时间之前可以直接从缓存里面获取数据，不需要再次向服务器发送请求。</li><li><code>Expires</code> 的优先级在三个 <code>Header</code> 属性中是最低的。</li></ul><div class="danger custom-block"><p class="custom-block-title">缺点</p><p>用 <code>Expires</code> 这个属性来控制是否使用强缓存有一个坑，就是有时候服务器的时间和浏览器的时间可能并不一致。导致服务器返回的这个过期时间不准确。所以 <code>Expires</code> 很快在后来的 HTTP1.1 版本中被抛弃了。</p></div><h3 id="cache-control" tabindex="-1">Cache-Control <a class="header-anchor" href="#cache-control" aria-label="Permalink to &quot;Cache-Control&quot;">​</a></h3><ul><li><p><code>Cache-Control</code> 是 <code>HTTP/1.1</code> 中新增的属性。</p></li><li><p>在请求头和响应头中都可以使用，它和 <code>Expires</code> 本质的不同在于它并没有采用具体的过期时间点这个方式，而是<strong>采用过期时长</strong>来控制缓存，对应的字段是<code>max-age</code>。</p></li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Cache</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Control</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">max</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">age</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">600</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面代码代表服务器返回响应之后 10 分钟内可以直接使用缓存。</p><p><strong>其他 <code>Cache-Control</code> 常用属性如下：</strong></p><ul><li><p>public：响应可以被中间代理、CDN 等缓存。</p></li><li><p>private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应。</p></li><li><p>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</p></li><li><p>no-store：禁止使用缓存。</p></li><li><p>no-cache: 跳过当前的强缓存，发送 HTTP 请求，即直接进入协商缓存阶段。</p></li></ul><p><strong>当 Expires 和 Cache-Control 同时存在的时候， Cache-Control 会优先考虑。</strong></p><h3 id="pragma" tabindex="-1">Pragma <a class="header-anchor" href="#pragma" aria-label="Permalink to &quot;Pragma&quot;">​</a></h3><ul><li><p><code>Pragma</code> 是一个在 <code>HTTP/1.0</code> 中规定的通用首部，这个首部的效果依赖于不同的实现，所以在“请求-响应”链中可能会有不同的效果。它用来向后兼容只支持 <code>HTTP/1.0</code> 协议的缓存服务器，那时候 <code>HTTP/1.1</code> 协议中的 <code>Cache-Control</code> 还没有出来。</p></li><li><p><code>Pragma</code> 只有一个属性值，就是 <code>no-cache</code> ，效果和 <code>Cache-Control</code> 中的 <code>no-cache</code> 一致，不使用强缓存，需要与服务器验证缓存是否新鲜。</p></li></ul><div class="danger custom-block"><p class="custom-block-title">注意</p><p>由于 <code>Pragma</code> 在 <code>HTTP</code> 响应中的行为没有确切规范，所以不能可靠替代 <code>HTTP/1.1</code> 中通用首部 <code>Cache-Control</code>，尽管在请求中，假如 <code>Cache-Control</code> 不存在的话，它的行为与 <code>Cache-Control: no-cache</code> 一致。建议只在需要兼容 <code>HTTP/1.0</code> 客户端的场合下应用 <code>Pragma</code> 首部。</p></div><h2 id="_2、协商缓存" tabindex="-1">2、协商缓存 <a class="header-anchor" href="#_2、协商缓存" aria-label="Permalink to &quot;2、协商缓存&quot;">​</a></h2><p>当浏览器的强缓存失效，或者请求头中设置了不走强缓存的时候。浏览器在请求头中携带 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 这两个属性来向服务器发请求，由服务器根据这两个属性来决定是否使用缓存，这就是<strong>协商缓存。</strong></p><h3 id="last-modified" tabindex="-1">Last-Modified <a class="header-anchor" href="#last-modified" aria-label="Permalink to &quot;Last-Modified&quot;">​</a></h3><ul><li><p><code>Last-Modified</code> 即最后修改时间，在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段，值为服务器返回数据的最后修改时间。</p></li><li><p>浏览器接收到后，如果再次发起同一个请求，会在请求头中携带<code>If-Modified-Since</code> 这个字段，这个字段的值也就是服务器传来的最后修改时间。</p></li><li><p>服务器拿到请求头中 <code>If-Modified-Since</code> 字段后，就拿它的值与服务器中该资源的最后修改时间相比一下。</p></li><li><p>如果请求头中的这个值小于最后修改时间，说明资源已经更新了。需要返回新的资源，跟常规的 <code>HTTP</code> 请求响应的流程一样。</p></li><li><p>否则说明资源没有发生改变，直接返回 304，告诉浏览器使用缓存。</p></li></ul><h3 id="etag-资源唯一标识" tabindex="-1">ETag（资源唯一标识） <a class="header-anchor" href="#etag-资源唯一标识" aria-label="Permalink to &quot;ETag（资源唯一标识）&quot;">​</a></h3><ul><li><p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会改变。在浏览器第一次给服务器发送请求后，服务器会通过响应头把这个值（请求资源的 <code>ETag</code>）给浏览器。</p></li><li><p>浏览器接收到 <code>ETag</code> 的值后，会在下次请求时将这个值作为<code>If-None-Match</code> 这个属性的值放到请求头中，然后发给服务器。</p></li><li><p>服务器接收到 <code>If-None-Match</code> 后，会跟服务器上该资源的 <code>ETag</code> 进行对比。</p></li><li><p>如果两者不一样，说明要更新了。返回新的资源，跟常规的 <code>HTTP</code> 请求响应的流程一样。</p></li><li><p>否则说明资源没有发生改变，直接返回 304，告诉浏览器使用缓存。</p></li></ul><h3 id="last-modified-vs-etag-资源唯一标识" tabindex="-1">Last-Modified VS ETag（资源唯一标识） <a class="header-anchor" href="#last-modified-vs-etag-资源唯一标识" aria-label="Permalink to &quot;Last-Modified VS ETag（资源唯一标识）&quot;">​</a></h3><p>在精准度上，<code>ETag</code> 优于 <code>Last-Modified</code>。因为 <code>ETag</code> 是按照内容给资源生成唯一标识，因此能准确感知资源的变化。而 <code>Last-Modified</code> 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:</p>',28),h=e("strong",null,"修改频率在秒级以下",-1),u=e("code",null,"Last-Modified/If-Modified-Since",-1),f=e("strong",null,"如果文件被修改了，但是内容没有任何变化",-1),T=e("p",null,[o("在性能上，"),e("code",null,"Last-Modified"),o(" 优于 "),e("code",null,"ETag"),o("，也很简单理解，"),e("code",null,"Last-Modified"),o(" 仅仅只是记录一个时间点，而 "),e("code",null,"Etag"),o(" 需要根据文件的具体内容生成哈希值。")],-1);function _(m,C,g,P,b,x){const a=i("font");return t(),s("div",null,[p,e("ul",null,[e("li",null,[e("p",null,[o("1、如果文件的"),c(a,{color:"red"},{default:d(()=>[h]),_:1}),o("，"),u,o(" 会错误地返回 304")])]),e("li",null,[e("p",null,[o("2、"),c(a,{color:"red"},{default:d(()=>[f]),_:1}),o("的时候，Last-Modified/If-Modified-Since 也会错误地返回 304")])])]),T,c(a,{color:"red"},{default:d(()=>[o("**如果两种方式都支持的话，服务器会优先考虑 `ETag`。**")]),_:1})])}const q=l(n,[["render",_]]);export{M as __pageData,q as default};
